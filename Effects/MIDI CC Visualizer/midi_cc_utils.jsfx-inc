// ===================================================================
// MIDI CC UTILITIES LIBRARY - MULTI-CHANNEL SUPPORT
// ===================================================================
// Utility functions for MIDI CC visualization with channel awareness
// This is a library file (.jsfx-inc) to be imported by JSFX plugins
//
// PROVIDES:
// - Color palette management (12-color system)
// - Color assignment and retrieval for CC numbers (channel-independent)
// - History buffer management (circular buffer with channel support)
// - (CC#, Channel) pair data management
// - Memory-safe data structures
//
// CHANGELOG (v0.5):
// - Added multi-channel support for CC data storage
// - History buffer now stores: time, cc_num, channel, value (was 3 items)
// - New data structure: (CC#, Channel) pairs as primary key
// - Colors remain CC#-based (independent of channel)
// - Added sorting and filtering by channel
// - Added helper functions for active (CC#, Channel) pair management
//
// USAGE:
// import midi_cc_utils.jsfx-inc
// ===================================================================

@init

// ========== MEMORY LAYOUT CONSTANTS ==========
// These define where data is stored in memory to avoid collisions
MEM_CC_VALUES = 0;           // mem[0-2047]: CC values per (CC#, Channel) pair - key format: (cc<<8)|channel
MEM_CC_ACTIVE = 2500;        // mem[2500-2627]: Active flags per CC# (independent of channel)
MEM_CC_CHANNEL_ACTIVE = 2700; // mem[2700-3700]: Active channel flags per CC# - format: bit array where bit N = channel N active
MEM_CC_SORTED = 3800;        // mem[3800-4100]: Sorted active (CC#, Channel) pair list
MEM_CC_SORTED_BY_CC = 4200;  // mem[4200-5200]: Sorted (CC#, Channel) pairs grouped by CC#
MEM_CC_COLORS = 5300;        // mem[5300-5427]: Color assignments (CC#-based, independent of channel)
MEM_COLOR_PALETTE = 5500;    // mem[5500-5699]: RGB color palette
MEM_HISTORY_BASE = 6000;     // mem[6000-15000]: History buffer (now stores 4 values per entry)
MEM_HISTORY_WRITE = 25000;   // Write position pointer
MEM_HISTORY_COUNT = 25001;   // Item count
MEM_NEXT_COLOR = 25002;      // Next color index to assign
MEM_PAIR_LIST_COUNT = 25003; // Count of active (CC#, Channel) pairs
MEM_PAIR_LIST_BY_CC_COUNT = 25004; // Count for grouped list

// ========== CONFIGURATION ==========
MAX_HISTORY_ITEMS = 2000;    // Maximum history buffer size
COLOR_PALETTE_SIZE = 12;     // Number of colors in palette
MAX_CC_CHANNEL_PAIRS = 2048; // Max (CC#, Channel) pairs (128 CCs Ã— 16 channels = 2048)

// ========== COLOR PALETTE INITIALIZATION ==========
// Highly distinct, bright colors optimized for dark backgrounds
function init_color_palette() (
  // Store RGB values in memory starting at MEM_COLOR_PALETTE
  // Each color uses 3 slots [R, G, B]
  
  // Color 0: Bright Red
  mem[5500] = 1.0; mem[5501] = 0.2; mem[5502] = 0.2;
  // Color 1: Bright Green
  mem[5503] = 0.2; mem[5504] = 1.0; mem[5505] = 0.3;
  // Color 2: Bright Blue
  mem[5506] = 0.3; mem[5507] = 0.5; mem[5508] = 1.0;
  // Color 3: Bright Yellow
  mem[5509] = 1.0; mem[5510] = 0.95; mem[5511] = 0.2;
  // Color 4: Bright Cyan
  mem[5512] = 0.2; mem[5513] = 0.95; mem[5514] = 0.95;
  // Color 5: Bright Magenta
  mem[5515] = 1.0; mem[5516] = 0.3; mem[5517] = 0.9;
  // Color 6: Bright Orange
  mem[5518] = 1.0; mem[5519] = 0.6; mem[5520] = 0.2;
  // Color 7: Bright Lime
  mem[5521] = 0.7; mem[5522] = 1.0; mem[5523] = 0.3;
  // Color 8: Bright Purple
  mem[5524] = 0.7; mem[5525] = 0.4; mem[5526] = 1.0;
  // Color 9: Bright Pink
  mem[5527] = 1.0; mem[5528] = 0.5; mem[5529] = 0.7;
  // Color 10: Bright Teal
  mem[5530] = 0.3; mem[5531] = 0.9; mem[5532] = 0.7;
  // Color 11: Bright Coral
  mem[5533] = 1.0; mem[5534] = 0.5; mem[5535] = 0.4;
);

// ========== COLOR MANAGEMENT ==========
// Assigns a unique color to a CC number when first received
// Colors are CC#-based (independent of channel)
function assign_color_to_cc(cc_num) local(color_idx, current_idx) (
  // Check if color already assigned
  color_idx = mem[MEM_CC_COLORS + cc_num];
  
  color_idx < 0 ? (
    // Not assigned yet, get next available color index
    current_idx = mem[MEM_NEXT_COLOR];
    
    // Ensure index is valid (0-11)
    current_idx < 0 ? current_idx = 0;
    current_idx >= COLOR_PALETTE_SIZE ? current_idx = 0;
    
    // Assign THIS color to THIS CC permanently
    mem[MEM_CC_COLORS + cc_num] = current_idx;
    
    // Increment for next CC (cycle 0-11)
    mem[MEM_NEXT_COLOR] = (current_idx + 1) % COLOR_PALETTE_SIZE;
  );
);

// Sets gfx color variables (gfx_r, gfx_g, gfx_b, gfx_a) to the color
// assigned to the given CC number (independent of channel)
function get_cc_color(cc_num) local(color_idx, base) (
  // Get assigned color index
  color_idx = mem[MEM_CC_COLORS + cc_num];
  
  // Safety check: if not assigned, assign now
  color_idx < 0 ? (
    assign_color_to_cc(cc_num);
    color_idx = mem[MEM_CC_COLORS + cc_num];
  );
  
  // Additional safety: ensure color index is valid
  color_idx < 0 || color_idx >= COLOR_PALETTE_SIZE ? (
    color_idx = 0;
  );
  
  // Get color from palette and set gfx variables
  base = MEM_COLOR_PALETTE + (color_idx * 3);
  gfx_r = mem[base];
  gfx_g = mem[base + 1];
  gfx_b = mem[base + 2];
  gfx_a = 1;
);

// ========== CC DATA MANAGEMENT (WITH CHANNEL SUPPORT) ==========

/**
 * Creates a unique key from CC number and channel
 * Format: (cc_num << 8) | channel
 * Used as index into memory arrays
 */
function make_cc_channel_key(cc_num, channel) (
  (cc_num << 8) | channel
);

/**
 * Stores a CC value for a specific (CC#, Channel) pair
 * @param cc_num CC number (0-127)
 * @param channel MIDI channel (0-15, where 0=channel 1, 15=channel 16)
 * @param cc_value CC value (0-127)
 */
function store_cc_channel_value(cc_num, channel, cc_value) local(key) (
  key = make_cc_channel_key(cc_num, channel);
  mem[MEM_CC_VALUES + key] = cc_value;
  mem[MEM_CC_ACTIVE + cc_num] = 1;  // Mark CC# as active
  
  // Mark this channel as active for this CC#
  mem[MEM_CC_CHANNEL_ACTIVE + cc_num] = mem[MEM_CC_CHANNEL_ACTIVE + cc_num] | (1 << channel);
);

/**
 * Retrieves a CC value for a specific (CC#, Channel) pair
 * @param cc_num CC number (0-127)
 * @param channel MIDI channel (0-15)
 * @return CC value (0-127) or 0 if not set
 */
function get_cc_channel_value(cc_num, channel) local(key) (
  key = make_cc_channel_key(cc_num, channel);
  mem[MEM_CC_VALUES + key]
);

// Checks if a CC number has been received (on any channel)
function is_cc_active(cc_num) (
  mem[MEM_CC_ACTIVE + cc_num]
);

// Checks if a specific (CC#, Channel) pair has been received
function is_cc_channel_active(cc_num, channel) local(key) (
  key = make_cc_channel_key(cc_num, channel);
  mem[MEM_CC_VALUES + key] >= 0
);

/**
 * Builds a sorted list of all active (CC#, Channel) pairs
 * Pairs are sorted by CC# first, then by channel
 * Results stored in MEM_CC_SORTED array
 * @return Total count of active (CC#, Channel) pairs
 */
function build_active_cc_channel_pair_list() local(count, cc, channel, channel_mask)
(
  count = 0;
  
  cc = 0;
  loop(128,
    mem[MEM_CC_ACTIVE + cc] == 1 ? (
      // This CC# is active, check which channels
      channel_mask = mem[MEM_CC_CHANNEL_ACTIVE + cc];
      
      channel = 0;
      loop(16,
        (channel_mask & (1 << channel)) ? (
          // This channel is active for this CC#
          mem[MEM_CC_SORTED + count] = make_cc_channel_key(cc, channel);
          count += 1;
        );
        channel += 1;
      );
    );
    cc += 1;
  );
  
  mem[MEM_PAIR_LIST_COUNT] = count;
  count
);

/**
 * Gets a (CC#, Channel) pair from the sorted active list
 * @param index Index into sorted list (0 = first pair)
 * @return Combined key (CC#, Channel) or -1 if invalid
 */
function get_active_cc_channel_pair(index) local(count) (
  count = mem[MEM_PAIR_LIST_COUNT];
  index >= count ? -1 : mem[MEM_CC_SORTED + index]
);

/**
 * Gets a (CC#, Channel) pair filtered by CC# and channel index
 * Useful when slider1 is set to a specific CC#
 * @param cc_num CC number to filter by (0-127)
 * @param channel_idx Which channel (0-15) for this CC# (0 = first active channel)
 * @return Combined key (CC#, Channel) or -1 if not found
 */
function get_active_cc_channel_pair_by_cc(cc_num, channel_idx) local(channel, channel_mask, active_channel_count, found_count, key)
(
  mem[MEM_CC_ACTIVE + cc_num] == 0 ? -1 : (
    channel_mask = mem[MEM_CC_CHANNEL_ACTIVE + cc_num];
    found_count = 0;
    
    channel = 0;
    loop(16,
      (channel_mask & (1 << channel)) ? (
        found_count == channel_idx ? (
          key = make_cc_channel_key(cc_num, channel);
          key
        );
        found_count += 1;
      );
      channel += 1;
    );
    
    -1  // Not found
  );
);

/**
 * Counts how many channels have a specific CC#
 * @param cc_num CC number to check (0-127)
 * @return Number of channels with this CC#
 */
function count_cc_channels(cc_num) local(channel_mask, count, channel)
(
  mem[MEM_CC_ACTIVE + cc_num] == 0 ? 0 : (
    channel_mask = mem[MEM_CC_CHANNEL_ACTIVE + cc_num];
    count = 0;
    
    channel = 0;
    loop(16,
      (channel_mask & (1 << channel)) ? count += 1;
      channel += 1;
    );
    
    count
  );
);



/**
 * Adds a data point to the history buffer with channel info
 * @param timestamp Time value (seconds)
 * @param cc_num CC number (0-127)
 * @param channel MIDI channel (0-15)
 * @param cc_value CC value (0-127)
 */
function add_to_history_with_channel(timestamp, cc_num, channel, cc_value) local(pos, base) 
(
  pos = mem[MEM_HISTORY_WRITE];  // Current write position
  base = MEM_HISTORY_BASE + (pos * 4);  // 4 items per entry now
  
  // Store the quadruplet
  mem[base] = timestamp;
  mem[base + 1] = cc_num;
  mem[base + 2] = channel;
  mem[base + 3] = cc_value;
  
  // Update write position (circular buffer)
  mem[MEM_HISTORY_WRITE] = (pos + 1) % MAX_HISTORY_ITEMS;
  
  // Update count (max at MAX_HISTORY_ITEMS)
  mem[MEM_HISTORY_COUNT] = min(mem[MEM_HISTORY_COUNT] + 1, MAX_HISTORY_ITEMS);
);


// ========== HISTORY BUFFER MANAGEMENT (WITH CHANNEL SUPPORT) ==========
// Circular buffer that stores [timestamp, cc_num, channel, cc_value] quadruplets
// Automatically overwrites oldest data when full

/**
 * Adds a data point to the history buffer (without channel)
 * DEPRECATED: Use add_to_history_with_channel() instead
 * @param timestamp Time value (seconds)
 * @param cc_num CC number (0-127)
 * @param cc_value CC value (0-127)
 */
function add_to_history(timestamp, cc_num, cc_value) 
(
  add_to_history_with_channel(timestamp, cc_num, 0, cc_value);
);


/**
 * Retrieves a history item by index (0 = oldest, count-1 = newest)
 * Returns base memory address of quadruplet, or -1 if invalid index
 * Access data as: mem[base] = timestamp, mem[base+1] = cc_num, 
 *                 mem[base+2] = channel, mem[base+3] = value
 * @param index History index (0 = oldest)
 * @return Memory base address or -1
 */
function get_history(index) local(count, write_pos, actual_pos, base)
(
  count = mem[MEM_HISTORY_COUNT];
  index >= count ? (
    -1  // Invalid index
  ) : (
    write_pos = mem[MEM_HISTORY_WRITE];
    
    // Calculate actual position in circular buffer
    count < MAX_HISTORY_ITEMS ? (
      // Buffer not full yet, items are sequential from 0
      actual_pos = index;
    ) : (
      // Buffer is full, oldest item is at write_pos
      actual_pos = (write_pos + index) % MAX_HISTORY_ITEMS;
    );
    
    base = MEM_HISTORY_BASE + (actual_pos * 4);  // 4 items per entry
    base  // Return base address
  );
);

// Returns the current number of items in history
function get_history_count() (
  mem[MEM_HISTORY_COUNT]
);

// Clears the history buffer
function clear_history() (
  mem[MEM_HISTORY_WRITE] = 0;
  mem[MEM_HISTORY_COUNT] = 0;
);

// ========== INITIALIZATION ==========
function init_cc_utils() local(i) (
  // Initialize CC values
  i = 0;
  loop(MAX_CC_CHANNEL_PAIRS,
    mem[MEM_CC_VALUES + i] = 0;
    i += 1;
  );
  
  // Initialize CC active flags
  i = 0;
  loop(128,
    mem[MEM_CC_ACTIVE + i] = 0;
    mem[MEM_CC_CHANNEL_ACTIVE + i] = 0;  // Bit array for channel flags
    i += 1;
  );
  
  // Initialize color assignments to -1 (unassigned)
  i = 0;
  loop(128,
    mem[MEM_CC_COLORS + i] = -1;
    i += 1;
  );
  
  // Initialize history pointers
  mem[MEM_HISTORY_WRITE] = 0;
  mem[MEM_HISTORY_COUNT] = 0;
  mem[MEM_NEXT_COLOR] = 0;
  mem[MEM_PAIR_LIST_COUNT] = 0;
  mem[MEM_PAIR_LIST_BY_CC_COUNT] = 0;
  
  // Initialize color palette
  init_color_palette();
);

// ========== AUTO-INITIALIZATION ==========
// Automatically initialize when library is imported
init_cc_utils();
