// ===================================================================
// MIDI CC VISUALIZER WITH REAL-TIME GRAPH AND PERFORMANCE METRICS
// ===================================================================
// Real-time visualization of MIDI Continuous Controller (CC) messages
// with dual display modes: time-based graphs and current value bars
// with integrated performance analysis metrics.
//
// FEATURES:
// - Real-time scrolling XY graph showing CC value changes over time
// - Horizontal bars displaying current CC values (0-127)
// - Performance metrics for hardware testing and technique analysis:
//   * Events per second: MIDI message frequency (hardware resolution)
//   * Rate (u/s): Value change velocity (playing intensity)
//   * Jitter: Timing consistency (hardware quality indicator)
// - Dynamic layout: graph area maximizes available space while bars
//   automatically adjust height based on number of active CCs
// - Unique persistent color per CC from 12-color palette (shared across channels)
// - Configurable time window (1-30 seconds)
// - Monitor all CCs simultaneously or focus on a single CC
// - Full 0-127 value range with grid lines and axis labels
// - Clean, minimal interface optimized for data clarity
// - MULTI-CHANNEL SUPPORT: Visualizes same CC# from different MIDI channels
//
// MULTI-CHANNEL SUPPORT (v0.5+):
// - Each CC# can appear on multiple MIDI channels (1-16)
// - Display format: "CC1 (CH:01)" shows CC number and MIDI channel
// - Sorting: Grouped by CC# then by channel for easy comparison
// - Color scheme: CC#-based coloring (same CC# = same color across channels)
// - Metrics: Tracked independently per (CC#, Channel) pair
// - History: Stores channel info with each data point
//
// PERFORMANCE METRICS EXPLAINED:
//
// Events per Second (Events: X/s):
//   - How many MIDI CC messages arrive per second
//   - High values (60+) = high-resolution controller
//   - Low values (10-20) = coarse updates or slow movements
//   - Useful for: Testing controller resolution and USB timing
//
// Rate (Rate: X u/s - units per second):
//   - How fast CC values are changing (sum of value deltas per second)
//   - Quality ratings: Gentle (0-15) | Moderate (16-40) | Active (41-70) | Aggressive (71+)
//   - Useful for: Analyzing playing technique and gesture intensity
//
// Jitter (Jitter: ±Xms):
//   - Timing consistency between MIDI events (standard deviation)
//   - Quality ratings: Excellent (<5ms) | Very Good (6-15ms) | Good (16-30ms) | Fair (31-50ms) | Poor (>50ms)
//   - Useful for: Hardware quality testing, detecting USB/timing issues
//
// DISPLAY FORMAT (per CC bar - v0.5.1+):
// CC01 (CH:01)  [████████████░░░░░░]  67    Events: 45/s    Rate: 23 u/s (Gentle)    Jitter: ±4ms (Excellent)
//
// CONTROLS:
// - Slider 1: CC to Monitor (0 = All CCs, 1-127 = specific CC)
// - Slider 3: Time Window in seconds (1-30)
//
// CHANGELOG (v0.5.1):
// - Refactored draw_cc_bars() function for improved UI clarity
// - Removed pipe separators (│) for cleaner single-line display
// - Added explicit metric labels: "Events:", "Rate:", "Jitter:"
// - Optimized spacing using natural gaps instead of visual dividers
// - Metrics now immediately identifiable without referencing documentation
//
// CHANGELOG (v0.5):
// - Added multi-channel MIDI support
// - Data structure changed from (cc_num) to (cc_num, channel) pairs
// - History buffer now stores: time, cc_num, channel, value
// - Color assignment remains CC#-based for visual consistency
// - Metrics tracked per (CC#, Channel) pair independently
// - Display shows "CCn (CH:XX)" format in bar labels
// - Bars sorted by CC# then by channel number
// - Refactored utility functions to handle channel parameter
// - Updated metric tracking to account for channel-specific streams
//
// ARCHITECTURE:
// - Modular function-based design for maintainability
// - Separate utility library (midi_cc_utils.jsfx-inc) for data management
// - Separate metrics library (midi_cc_metrics.jsfx-inc) for performance analysis
// - Efficient memory management for history buffer and metrics
// - All metrics calculated over 1-second rolling window for real-time feedback
// ===================================================================

desc:MIDI CC Visualizer with Real-Time Graph and Metrics
author: Giorgio Robino
version: 0.5
date: 2025-11-22

// Import utility libraries
import midi_cc_utils.jsfx-inc
import midi_cc_metrics.jsfx-inc

options:no_meter
slider1:0<0,127,1>CC to Monitor (0=All)
slider3:10<1,30,1>Time Window (seconds)

@init
// ========== CONFIGURATION VARIABLES ==========
FONT_SIZE = 16;          // Text size
BAR_HEIGHT = 8;          // Height of each CC bar
BAR_SPACING = 8;         // Space between bars
MIN_BAR_SECTION = 80;    // Minimum height for bar section
MAX_BAR_PROPORTION = 0.35; // Bars take max 35% of window
Y_AXIS_PADDING = 0.05;   // 5% padding top and bottom for Y-axis
STATUS_TEXT_MARGIN = 25; // Space for status text at bottom

// ========== GLOBAL LAYOUT VARIABLES ==========
g_graph_height = 0;
g_bars_height = 0;
g_start_y = 0;
g_label_width = 0;
g_value_width = 0;
g_margin = 0;
g_available_width = 0;
g_max_bars = 0;
g_visible_bars = 0;
g_separator_y = 0;
g_graph_start_y = 0;
g_graph_margin_left = 0;
g_graph_margin_right = 0;
g_graph_margin_bottom = 0;
g_graph_width = 0;
g_graph_actual_height = 0;
g_y_range_min = 0;
g_y_range_max = 0;
g_y_range_total = 0;

// ========== TIME WINDOW VARIABLES ==========
g_time_window = 0;
g_time_start = 0;
g_time_end = 0;

// ========== METRICS VARIABLES ==========
g_last_prune_time = 0;
PRUNE_INTERVAL = 0.1; // Prune old metrics every 100ms

// ========== FUNCTION DEFINITIONS ==========

/**
 * Creates a unique key from CC number and channel for use as dictionary key
 * Format: (cc_num << 8) | channel
 * This ensures each (CC#, Channel) pair has a unique identifier
 * 
 * @param cc_num CC number (0-127)
 * @param channel MIDI channel (0-15, where 0=channel 1, 15=channel 16)
 * @return Unique integer key
 */
function make_cc_channel_key(cc_num, channel) (
  (cc_num << 8) | channel
);

/**
 * Extracts CC number from a combined (CC, Channel) key
 * 
 * @param key Combined key from make_cc_channel_key()
 * @return CC number (0-127)
 */
function key_to_cc(key) (
  (key >> 8) & 0x7F
);

/**
 * Extracts channel from a combined (CC, Channel) key
 * 
 * @param key Combined key from make_cc_channel_key()
 * @return MIDI channel (0-15, where 0=channel 1, 15=channel 16)
 */
function key_to_channel(key) (
  key & 0x0F
);

/**
 * Calculates all layout dimensions for the UI with dynamic sizing
 * 
 * This function computes:
 * - Bar section height based on number of active CCs (dynamic!)
 * - Graph section gets ALL remaining space (maximized!)
 * - Bar positioning and spacing (at bottom)
 * - Graph margins and dimensions (at top)
 * - Y-axis range with padding
 * 
 * Results are stored in global g_* variables for use by drawing functions
 * 
 * @param filtered_count Number of (CC#, Channel) pairs to display in bars section
 */
function calculate_layout(filtered_count) local(required_bar_height, max_bar_height) (
  
  // Calculate MINIMUM height needed for bars based on actual (CC, Channel) pair count
  required_bar_height = (filtered_count * (BAR_HEIGHT + BAR_SPACING)) + STATUS_TEXT_MARGIN + 20;
  required_bar_height = max(required_bar_height, MIN_BAR_SECTION);
  
  // Ensure bars don't dominate the window (max 35% of total height)
  max_bar_height = floor(gfx_h * MAX_BAR_PROPORTION);
  g_bars_height = min(required_bar_height, max_bar_height);
  
  // ========== GRAPH GETS ALL REMAINING SPACE ==========
  g_graph_height = gfx_h - g_bars_height;
  
  // ========== GRAPH IS AT TOP ==========
  g_graph_start_y = 10;
  g_graph_margin_left = 35;
  g_graph_margin_right = 10;
  g_graph_margin_bottom = 10;
  g_graph_width = gfx_w - g_graph_margin_left - g_graph_margin_right;
  g_graph_actual_height = g_graph_height - g_graph_margin_bottom;
  
  // ========== BARS ARE AT BOTTOM ==========
  g_start_y = g_graph_start_y + g_graph_height + 10;
  g_label_width = FONT_SIZE * 6;  // Increased for "CC1 (CH:01)" format
  g_value_width = FONT_SIZE * 3;
  g_margin = 20;
  g_available_width = gfx_w - g_label_width - g_value_width - g_margin * 2;
  
  // Calculate how many bars can fit in allocated space
  available_bar_space = g_bars_height - STATUS_TEXT_MARGIN;
  g_max_bars = floor(available_bar_space / (BAR_HEIGHT + BAR_SPACING));
  g_visible_bars = min(filtered_count, g_max_bars);
  
  // Calculate Y-axis range with padding
  g_y_range_min = 0 - (127 * Y_AXIS_PADDING);
  g_y_range_max = 127 + (127 * Y_AXIS_PADDING);
  g_y_range_total = g_y_range_max - g_y_range_min;
);

/**
 * Calculates the time window parameters in SECONDS
 * 
 * Sets:
 * - g_time_window: Duration of visible time window (seconds)
 * - g_time_start: Start time of visible window (seconds)
 * - g_time_end: End time of visible window (seconds)
 */
function calculate_time_window() local(current_time_sec) (
  current_time_sec = time_precise();
  
  g_time_window = slider3;
  g_time_end = current_time_sec;
  g_time_start = g_time_end - g_time_window;
);


/**
 * Draws horizontal bars showing current CC values with performance metrics
 * 
 * For each active/filtered (CC#, Channel) pair:
 * - Draws CC number and channel label
 * - Draws colored bar proportional to CC value (0-127)
 * - Draws "Value: X" label with clear metric identification
 * - Draws performance metrics with explicit labels: Events, Rate, Jitter
 * 
 * DISPLAY FORMAT (v0.5.1):
 * CC01 (CH:01)  [████████████░░░░░░]  67    Events: 45/s    Rate: 23 u/s (Gentle)    Jitter: ±4ms (Excellent)
 * 
 * CHANGES (v0.5.2):
 * - Made bar width and metrics layout fully responsive to window resize
 * - Bar width now scales dynamically based on available horizontal space
 * - Metrics text position adapts proportionally to window width
 * - Maintains optimal visual proportions across all window sizes
 * 
 * CHANGES (v0.5.1):
 * - Removed pipe separators (│) for cleaner appearance
 * - Added "Value:" label to CC value display for clarity
 * - Added explicit metric labels: "Events:", "Rate:", "Jitter:"
 * - Optimized spacing using natural gaps instead of visual separators
 * - Improved readability by clearly identifying each metric
 * - Single-line format maintained for high CC count scenarios
 * 
 * Uses global layout variables set by calculate_layout()
 */
function draw_cc_bars() local(y_pos, i, cc_channel_pair, cc_num, channel, val, bar_x, width, bar_width,
                               events_ps, rate_ps, rate_quality, jitter_ms, jitter_quality, metrics_x) (
  y_pos = g_start_y;
  i = 0;
  
  // Calculate bar width as percentage of available window width (fully responsive!)
  // Bar takes 35% of total window width to leave room for metrics text in default window
  bar_width = floor((gfx_w - g_margin * 2 - g_label_width) * 0.35);
  bar_width = max(bar_width, 50); // Minimum bar width for readability
  
  loop(g_visible_bars,
    cc_channel_pair = get_active_cc_channel_pair(i);
    cc_num = key_to_cc(cc_channel_pair);
    channel = key_to_channel(cc_channel_pair);
    val = get_cc_channel_value(cc_num, channel);
    
    // Set color for this CC (based on CC number only)
    get_cc_color(cc_num);
    
    // Draw CC number and channel label
    gfx_x = g_margin;
    gfx_y = y_pos + (BAR_HEIGHT - FONT_SIZE) / 2;
    gfx_printf("CC%02d/CH%02d", cc_num, channel + 1);  // channel + 1 for display (1-16 instead of 0-15)

    
    // Calculate and draw bar
    bar_x = g_margin + g_label_width;
    width = (val / 127.0) * bar_width;
    width = max(width, 2);
    
    gfx_rect(bar_x, y_pos, width, BAR_HEIGHT);
    
    // Draw value number
    gfx_x = bar_x + bar_width + 8;
    gfx_y = y_pos + (BAR_HEIGHT - FONT_SIZE) / 2;
    gfx_printf("Value: %d", val);
    
    // Get metrics for this (CC, Channel) pair
    events_ps = get_events_per_second_cc_channel(cc_num, channel);
    rate_ps = floor(get_rate_per_second_cc_channel(cc_num, channel));
    rate_quality = get_rate_quality(rate_ps);
    jitter_ms = floor(get_jitter_ms_cc_channel(cc_num, channel));
    jitter_quality = get_jitter_quality(jitter_ms);
    
    // Draw metrics text with responsive positioning (uses remaining window space)
    gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7; gfx_a = 1;
    metrics_x = bar_x + bar_width + 80; // Leave proper spacing after value number
    gfx_x = metrics_x;
    gfx_y = y_pos + (BAR_HEIGHT - FONT_SIZE) / 2;
    
    events_ps > 0 ? (
      gfx_printf("Events: %d/s    Rate: %d u/s (%s)    Jitter: ±%dms (%s)", 
                 events_ps, rate_ps, rate_quality, jitter_ms, jitter_quality);
    ) : (
      gfx_printf("No activity in last second");
    );
    
    y_pos += BAR_HEIGHT + BAR_SPACING;
    i += 1;
  );
);


/**
 * Draws the graph grid lines without background
 * 
 * Creates:
 * - Horizontal grid lines at CC values: 0, 32, 64, 96, 127
 * - Y-axis value labels on the left side
 * - Clean, minimal appearance without dark background
 */
function draw_graph_background() local(grid_values_count, grid_values_idx, grid_y, y) (
  // Draw horizontal grid lines (CC value levels) - no background!
  gfx_r = 0.3; gfx_g = 0.3; gfx_b = 0.3; gfx_a = 1;
  gfx_setfont(1, "Arial", FONT_SIZE - 2);
  
  grid_values_count = 5;
  grid_values_idx = 0;
  loop(grid_values_count,
    grid_values_idx == 0 ? grid_y = 0 :
    grid_values_idx == 1 ? grid_y = 32 :
    grid_values_idx == 2 ? grid_y = 64 :
    grid_values_idx == 3 ? grid_y = 96 :
    grid_y = 127;
    
    y = g_graph_start_y + g_graph_actual_height - ((grid_y - g_y_range_min) / g_y_range_total) * g_graph_actual_height;
    gfx_line(g_graph_margin_left, y, g_graph_margin_left + g_graph_width, y);
    
    // Draw value labels on left
    gfx_x = g_graph_margin_left - 30;
    gfx_y = y - FONT_SIZE / 2;
    gfx_printf("%d", grid_y);
    
    grid_values_idx += 1;
  );
  
  // Restore normal font size
  gfx_setfont(1, "Arial", FONT_SIZE);
);

/**
 * Draws vertical time grid lines and labels on X-axis
 * 
 * Creates tick marks every 1 second with time labels showing
 * seconds relative to the oldest visible point in the window
 */
function draw_time_grid() local(tick_interval, first_tick_time, current_tick_time, 
                                 relative_time, x_pos) (
  gfx_r = 0.4; gfx_g = 0.4; gfx_b = 0.4; gfx_a = 1;
  
  // Draw vertical grid lines every second
  tick_interval = 1;
  
  // Calculate first tick position aligned with time_start
  first_tick_time = ceil(g_time_start / tick_interval) * tick_interval;
  current_tick_time = first_tick_time;
  
  // Draw ticks within the visible window
  while (current_tick_time <= g_time_end) (
    g_time_window > 0 ? (
      // Calculate position relative to window
      relative_time = current_tick_time - g_time_start;
      x_pos = g_graph_margin_left + (relative_time / g_time_window) * g_graph_width;
      
      x_pos >= g_graph_margin_left && x_pos <= g_graph_margin_left + g_graph_width ? (
        // Draw vertical grid line
        gfx_line(x_pos, g_graph_start_y, x_pos, g_graph_start_y + g_graph_actual_height);
      );
    );
    
    current_tick_time += tick_interval;
  );
);

/**
 * Draws CC data lines and points on the graph
 * 
 * For each active (CC#, Channel) pair (or selected CC#):
 * - Scans through history buffer
 * - Filters data within visible time window
 * - Draws lines connecting consecutive points
 * - Draws dots at each data point
 * - Draws border around graph area
 * 
 * Uses color assigned to each CC number (shared across channels)
 * 
 * @param active_count Total number of active (CC#, Channel) pairs
 */
function draw_cc_data_lines(active_count) local(history_count, cc_draw_count, cc_idx, cc_channel_pair,
                                                 cc_num, channel, first_point, prev_x, prev_y, hist_idx, base,
                                                 h_time, h_cc, h_channel, h_val, relative_time, x, y) (
  history_count = get_history_count();
  
  // For each active (CC, Channel) pair (or just selected CC)
  cc_draw_count = slider1 != 0 ? active_count : active_count;  // When slider1 is set, we filter by CC# but show all channels
  cc_idx = 0;
  
  loop(cc_draw_count,
    cc_channel_pair = slider1 != 0 ? get_active_cc_channel_pair_by_cc(slider1, cc_idx) : get_active_cc_channel_pair(cc_idx);
    
    cc_channel_pair >= 0 ? (
      cc_num = key_to_cc(cc_channel_pair);
      channel = key_to_channel(cc_channel_pair);
      
      // Set color for this CC (based on CC number only)
      get_cc_color(cc_num);
      
      // Scan through history and draw this (CC, Channel) pair's data
      first_point = 1;
      prev_x = 0;
      prev_y = 0;
      
      hist_idx = 0;
      loop(history_count,
        base = get_history(hist_idx);
        base >= 0 ? (
          h_time = mem[base];
          h_cc = mem[base + 1];
          h_channel = mem[base + 2];
          h_val = mem[base + 3];
          
          // Check if this entry matches current (CC, Channel) pair and is within time window
          h_cc == cc_num && h_channel == channel && h_time >= g_time_start && h_time <= g_time_end ? (
            g_time_window > 0 ? (
              // Calculate X position using RELATIVE time from window start
              relative_time = h_time - g_time_start;
              x = g_graph_margin_left + (relative_time / g_time_window) * g_graph_width;
              
              // Calculate Y position with padding
              y = g_graph_start_y + g_graph_actual_height - ((h_val - g_y_range_min) / g_y_range_total) * g_graph_actual_height;
              
              // Draw line from previous point
              first_point == 0 ? (
                gfx_line(prev_x, prev_y, x, y);
              );
              
              // Draw dot at data point
              gfx_circle(x, y, 2, 1);
              
              prev_x = x;
              prev_y = y;
              first_point = 0;
            );
          );
        );
        hist_idx += 1;
      );
    );
    
    cc_idx += 1;
  );
  
  // Draw graph border for definition
  gfx_r = 0.5; gfx_g = 0.5; gfx_b = 0.5; gfx_a = 1;
  gfx_rect(g_graph_margin_left, g_graph_start_y, g_graph_width, g_graph_actual_height, 0);
);

/**
 * Draws status information text at the bottom of the UI
 * 
 * Displays:
 * - Waiting message if no data received
 * - Time window settings and history point count
 * 
 * @param filtered_count Number of active/filtered (CC#, Channel) pairs
 * @param history_count Number of points in history buffer
 */
function draw_status_info(filtered_count, history_count) local() (
  gfx_r = 0.6; gfx_g = 0.6; gfx_b = 0.6; gfx_a = 1;
  gfx_x = 10;
  gfx_y = gfx_h - STATUS_TEXT_MARGIN + 5;
  
  filtered_count == 0 ? (
    slider1 != 0 ? (
      gfx_printf("Waiting for CC%d data (any channel)...", slider1);
    ) : (
      gfx_drawstr("Send MIDI CC data to visualize.");
    );
  ) : (
    gfx_printf("Time: %d sec window | %d points in history | Metrics: 1-second rolling window", 
               slider3, history_count);
  );
);

/**
 * Processes incoming MIDI messages in the audio block
 * 
 * Handles CC messages (0xB0):
 * - Extracts MIDI channel from message
 * - Assigns color to new CCs (based on CC number only)
 * - Stores current CC values per (CC#, Channel) pair
 * - Adds timestamped entries to history buffer with channel info
 * - Updates performance metrics per (CC#, Channel) pair
 * - Passes all MIDI through unchanged
 */
function process_midi_messages() local(offset, msg1, msg2, msg3, status, cc_num, cc_val,
                                        midi_channel, current_time_sec) (
  // Get current time in seconds
  current_time_sec = time_precise();
  
  // Process MIDI messages
  while (midirecv(offset, msg1, msg2, msg3)) (
    status = msg1 & 0xF0;
    
    // Check if this is a CC message (0xB0)
    status == 0xB0 ? (
      cc_num = msg2 & 0x7F;
      cc_val = msg3 & 0x7F;
      midi_channel = msg1 & 0x0F;  // Extract MIDI channel (0-15)
      
      // Assign color IMMEDIATELY when CC is first received (based on CC number only)
      is_cc_active(cc_num) == 0 ? (
        assign_color_to_cc(cc_num);
      );
      
      // Store CC value for this (CC#, Channel) pair
      store_cc_channel_value(cc_num, midi_channel, cc_val);
      
      // Add to history with timestamp in SECONDS and channel info
      add_to_history_with_channel(current_time_sec, cc_num, midi_channel, cc_val);
      
      // Update metrics for this (CC#, Channel) pair
      update_metrics_for_cc_channel(cc_num, midi_channel, cc_val, current_time_sec);
    );
    
    // Pass MIDI through
    midisend(offset, msg1, msg2, msg3);
  );
  
  // Periodically prune old metrics (every 100ms)
  current_time_sec - g_last_prune_time > PRUNE_INTERVAL ? (
    prune_old_metrics(current_time_sec);
    g_last_prune_time = current_time_sec;
  );
);

@block
// Process all MIDI messages in this audio block
process_midi_messages();

@sample
// No per-sample processing needed

@gfx 1000 720
// ========== MAIN RENDERING PIPELINE ==========

// Clear background
gfx_clear = 0;
gfx_mode = 0;

// Set font size
gfx_setfont(1, "Arial", FONT_SIZE);

// ========== BUILD SORTED LIST OF ACTIVE (CC#, Channel) PAIRS ==========
active_count = build_active_cc_channel_pair_list();

// ========== APPLY CC FILTER ==========
filtered_count = 0;
slider1 != 0 ? (
  // Count how many channels have this CC#
  filtered_count = count_cc_channels(slider1);
) : (
  // Show all active (CC#, Channel) pairs
  filtered_count = active_count;
);

// ========== CALCULATE DYNAMIC LAYOUT ==========
calculate_layout(filtered_count);

// ========== CALCULATE TIME WINDOW ==========
calculate_time_window();

// ========== DRAW UI ELEMENTS ==========
draw_graph_background();
draw_time_grid();
draw_cc_data_lines(active_count);
draw_cc_bars();

// Get history count for status display
history_count = get_history_count();
draw_status_info(filtered_count, history_count);
