// ===================================================================
// MIDI CC METRICS LIBRARY
// ===================================================================
// Real-time performance metrics for MIDI Continuous Controller analysis
// Provides event rate, value change rate, and timing jitter calculations
// for hardware controller testing and performance analysis.
//
// METRICS EXPLAINED:
//
// 1. EVENTS PER SECOND (evt/s)
//    - Counts how many MIDI CC messages are received per second
//    - Example: 45 evt/s means 45 MIDI messages in the last second
//    - High values (60+): High-resolution controller sending frequent updates
//    - Low values (10-20): Low-resolution or slow movements
//    - Zero: No activity (static CC value)
//    - Use case: Detect controller resolution and USB/MIDI timing
//
// 2. RATE (u/s - units per second)
//    - Measures how fast CC VALUES are changing (not timing)
//    - Calculated as: sum of |current_value - previous_value| per second
//    - Example: CC goes 60→65→70→75 in 1 sec = rate of 15 u/s
//    - Quality ratings:
//      * Gentle (0-15 u/s): Slow fades, subtle dynamics
//      * Moderate (16-40 u/s): Normal playing, controlled changes
//      * Active (41-70 u/s): Expressive playing, clear gestures
//      * Aggressive (71+ u/s): Fast swells, dramatic movements
//    - Use case: Analyze playing technique and gesture intensity
//
// 3. JITTER (milliseconds ±)
//    - Measures consistency of event timing (not values)
//    - Calculated as: standard deviation of time intervals between events
//    - Example: Events at 0.0s, 0.1s, 0.2s, 0.3s = ±0ms (perfect)
//    - Example: Events at 0.0s, 0.05s, 0.25s, 0.3s = ±50ms (jittery)
//    - Quality ratings:
//      * Excellent (0-5ms): Professional-grade controller
//      * Very Good (6-15ms): High-quality consumer device
//      * Good (16-30ms): Acceptable for most uses
//      * Fair (31-50ms): Noticeable timing issues
//      * Poor (51+ms): Significant latency problems
//    - Use case: Hardware quality testing, USB timing diagnosis
//
// DISPLAY FORMAT:
// CC1  [████████████████░░░░░░░░] 67  │ Events: 45/s │ Rate: 23 u/s (Gentle) │ Jitter: ±4ms (Excellent)
// │    │                         │    │              │                        │
// │    │                         │    │              │                        └─ Timing consistency
// │    │                         │    │              └─ Value change speed with quality
// │    │                         │    └─ MIDI messages per second
// │    │                         └─ Current CC value (0-127)
// │    └─ Visual bar representation
// └─ CC number
//
// TECHNICAL DETAILS:
// - All metrics calculated over a 1-second rolling window
// - Window slides continuously (not reset)
// - Old events automatically pruned when older than 1 second
// - Metrics update smoothly without flickering
// - Memory efficient: stores only last 1 second of events per CC
//
// MEMORY LAYOUT (per CC):
// - Event buffer: stores timestamps and values for last 1 second
// - Each event: 2 floats (timestamp, value)
// - Max ~200 events per CC (enough for 200 evt/s resolution)
// ===================================================================

@init

// ========== CONFIGURATION ==========
METRICS_WINDOW_SEC = 1.0;      // Rolling window duration
MAX_EVENTS_PER_CC = 200;       // Buffer size per CC (supports up to 200 evt/s)

// ========== MEMORY ALLOCATION ==========
// Memory layout: base = 50000 (avoid conflict with other modules)
// Each CC gets a dedicated memory block
metrics_base = 50000;

// Per-CC memory structure (each CC uses 600 slots):
// [0]: event_count (number of events in buffer)
// [1]: last_value (previous CC value for rate calculation)
// [2-601]: event buffer (200 events × 3 slots each)
//   Each event: [timestamp, value, delta]

CC_BLOCK_SIZE = 600;

/**
 * Initializes the metrics system
 * Clears all buffers and resets counters
 */
function init_metrics() local(cc) (
  cc = 0;
  loop(128,
    mem[metrics_base + cc * CC_BLOCK_SIZE] = 0; // Clear event count
    mem[metrics_base + cc * CC_BLOCK_SIZE + 1] = -1; // Mark as uninitialized
    cc += 1;
  );
);

/**
 * Gets the memory address for a specific CC's metrics block
 * @param cc_num CC number (0-127)
 * @return Memory address of CC's metrics block
 */
function get_cc_metrics_base(cc_num) (
  metrics_base + cc_num * CC_BLOCK_SIZE
);

/**
 * Adds a new event to the metrics buffer for a CC
 * @param cc_num CC number (0-127)
 * @param value CC value (0-127)
 * @param time_sec Timestamp in seconds
 */
function update_metrics_for_cc(cc_num, value, time_sec) 
  local(base, count, last_val, delta, event_idx, event_ptr) (
  
  base = get_cc_metrics_base(cc_num);
  count = mem[base];
  last_val = mem[base + 1];
  
  // Calculate value delta (for rate calculation)
  delta = last_val >= 0 ? abs(value - last_val) : 0;
  
  // Store this value as last_value for next time
  mem[base + 1] = value;
  
  // Add event to buffer (if space available)
  count < MAX_EVENTS_PER_CC ? (
    event_idx = count;
    event_ptr = base + 2 + (event_idx * 3);
    
    mem[event_ptr] = time_sec;      // Timestamp
    mem[event_ptr + 1] = value;     // CC value
    mem[event_ptr + 2] = delta;     // Value change delta
    
    mem[base] = count + 1;          // Increment count
  );
);

/**
 * Removes events older than METRICS_WINDOW_SEC from all CC buffers
 * @param current_time_sec Current time in seconds
 */
function prune_old_metrics(current_time_sec) 
  local(cc, base, count, cutoff_time, src_idx, dst_idx, event_ptr, event_time) (
  
  cutoff_time = current_time_sec - METRICS_WINDOW_SEC;
  
  cc = 0;
  loop(128,
    base = get_cc_metrics_base(cc);
    count = mem[base];
    
    count > 0 ? (
      dst_idx = 0;
      src_idx = 0;
      
      // Compact buffer: keep only recent events
      loop(count,
        event_ptr = base + 2 + (src_idx * 3);
        event_time = mem[event_ptr];
        
        // Keep this event if it's recent enough
        event_time >= cutoff_time ? (
          src_idx != dst_idx ? (
            // Copy event to new position
            mem[base + 2 + (dst_idx * 3)] = mem[event_ptr];
            mem[base + 2 + (dst_idx * 3) + 1] = mem[event_ptr + 1];
            mem[base + 2 + (dst_idx * 3) + 2] = mem[event_ptr + 2];
          );
          dst_idx += 1;
        );
        
        src_idx += 1;
      );
      
      // Update count
      mem[base] = dst_idx;
    );
    
    cc += 1;
  );
);

/**
 * Calculates events per second for a CC
 * @param cc_num CC number (0-127)
 * @return Number of events in the last second
 */
function get_events_per_second(cc_num) local(base) (
  base = get_cc_metrics_base(cc_num);
  mem[base] // Event count IS the events per second (in 1-second window)
);

/**
 * Calculates rate (value change per second) for a CC
 * @param cc_num CC number (0-127)
 * @return Sum of absolute value changes per second
 */
function get_rate_per_second(cc_num) 
  local(base, count, total_delta, i, event_ptr) (
  
  base = get_cc_metrics_base(cc_num);
  count = mem[base];
  
  total_delta = 0;
  i = 0;
  
  loop(count,
    event_ptr = base + 2 + (i * 3);
    total_delta += mem[event_ptr + 2]; // Sum deltas
    i += 1;
  );
  
  total_delta
);

/**
 * Returns quality rating text for rate value
 * @param rate_value Rate in units per second
 * @return Quality string: "Gentle", "Moderate", "Active", or "Aggressive"
 */
function get_rate_quality(rate_value) (
  rate_value <= 15 ? "Gentle" :
  rate_value <= 40 ? "Moderate" :
  rate_value <= 70 ? "Active" :
  "Aggressive"
);

/**
 * Calculates jitter (timing consistency) for a CC
 * Returns standard deviation of time intervals between events
 * @param cc_num CC number (0-127)
 * @return Jitter in milliseconds (±)
 */
function get_jitter_ms(cc_num) 
  local(base, count, i, event_ptr, prev_time, curr_time, interval,
        sum_intervals, mean_interval, sum_squared_diff, variance, stddev) (
  
  base = get_cc_metrics_base(cc_num);
  count = mem[base];
  
  // Need at least 2 events to calculate jitter
  count < 2 ? (
    0
  ) : (
    // Calculate mean interval
    sum_intervals = 0;
    i = 1;
    loop(count - 1,
      prev_time = mem[base + 2 + ((i - 1) * 3)];
      curr_time = mem[base + 2 + (i * 3)];
      sum_intervals += (curr_time - prev_time);
      i += 1;
    );
    mean_interval = sum_intervals / (count - 1);
    
    // Calculate variance
    sum_squared_diff = 0;
    i = 1;
    loop(count - 1,
      prev_time = mem[base + 2 + ((i - 1) * 3)];
      curr_time = mem[base + 2 + (i * 3)];
      interval = curr_time - prev_time;
      sum_squared_diff += (interval - mean_interval) * (interval - mean_interval);
      i += 1;
    );
    variance = sum_squared_diff / (count - 1);
    
    // Standard deviation in milliseconds
    stddev = sqrt(variance) * 1000;
    stddev
  );
);

/**
 * Returns quality rating text for jitter value
 * @param jitter_ms Jitter in milliseconds
 * @return Quality string: "Excellent", "Very Good", "Good", "Fair", or "Poor"
 */
function get_jitter_quality(jitter_ms) (
  jitter_ms <= 5 ? "Excellent" :
  jitter_ms <= 15 ? "Very Good" :
  jitter_ms <= 30 ? "Good" :
  jitter_ms <= 50 ? "Fair" :
  "Poor"
);

// Initialize metrics system
init_metrics();