// ===================================================================
// MIDI CC METRICS LIBRARY - MULTI-CHANNEL SUPPORT
// ===================================================================
// Real-time performance metrics for MIDI Continuous Controller analysis
// Provides event rate, value change rate, and timing jitter calculations
// with full support for multi-channel MIDI data.
//
// METRICS EXPLAINED:
//
// 1. EVENTS PER SECOND (evt/s)
//    - Counts how many MIDI CC messages are received per second
//    - Example: 45 evt/s means 45 MIDI messages in the last second
//    - High values (60+): High-resolution controller sending frequent updates
//    - Low values (10-20): Low-resolution or slow movements
//    - Zero: No activity (static CC value)
//    - Use case: Detect controller resolution and USB/MIDI timing
//
// 2. RATE (u/s - units per second)
//    - Measures how fast CC VALUES are changing (not timing)
//    - Calculated as: sum of |current_value - previous_value| per second
//    - Example: CC goes 60→65→70→75 in 1 sec = rate of 15 u/s
//    - Quality ratings:
//      * Gentle (0-15 u/s): Slow fades, subtle dynamics
//      * Moderate (16-40 u/s): Normal playing, controlled changes
//      * Active (41-70 u/s): Expressive playing, clear gestures
//      * Aggressive (71+ u/s): Fast swells, dramatic movements
//    - Use case: Analyze playing technique and gesture intensity
//
// 3. JITTER (milliseconds ±)
//    - Measures consistency of event timing (not values)
//    - Calculated as: standard deviation of time intervals between events
//    - Example: Events at 0.0s, 0.1s, 0.2s, 0.3s = ±0ms (perfect)
//    - Example: Events at 0.0s, 0.05s, 0.25s, 0.3s = ±50ms (jittery)
//    - Quality ratings:
//      * Excellent (0-5ms): Professional-grade controller
//      * Very Good (6-15ms): High-quality consumer device
//      * Good (16-30ms): Acceptable for most uses
//      * Fair (31-50ms): Noticeable timing issues
//      * Poor (51+ms): Significant latency problems
//    - Use case: Hardware quality testing, USB timing diagnosis
//
// DISPLAY FORMAT:
// CC1 (CH:01) [████████████████░░░░░░░░] 67  │ Events: 45/s │ Rate: 23 u/s (Gentle) │ Jitter: ±4ms (Excellent)
//
// CHANGELOG (v0.5):
// - Added multi-channel metrics tracking
// - Each (CC#, Channel) pair maintains independent metrics
// - Memory layout updated to support 128 CCs × 16 channels
// - New functions for channel-aware metric retrieval
// - Pruning algorithm updated for channel-aware data
//
// TECHNICAL DETAILS:
// - All metrics calculated over a 1-second rolling window
// - Window slides continuously (not reset)
// - Old events automatically pruned when older than 1 second
// - Metrics update smoothly without flickering
// - Memory efficient: stores only last 1 second of events per (CC#, Channel) pair
//
// MEMORY LAYOUT (per CC per Channel):
// - Event buffer: stores timestamps and values for last 1 second
// - Each event: 3 floats (timestamp, value, delta)
// - Max ~200 events per (CC#, Channel) pair
// ===================================================================

@init

// ========== CONFIGURATION ==========
METRICS_WINDOW_SEC = 1.0;      // Rolling window duration
MAX_EVENTS_PER_CC = 200;       // Buffer size per CC (supports up to 200 evt/s)

// ========== MEMORY ALLOCATION ==========
// Memory layout: base = 30000 (avoid conflict with other modules)
// Supports 128 CCs × 16 channels = 2048 (CC#, Channel) pairs
// Each pair gets a dedicated memory block

metrics_base = 30000;

// Per-(CC#, Channel) memory structure (each uses 600 slots):
// [0]: event_count (number of events in buffer)
// [1]: last_value (previous CC value for rate calculation)
// [2-601]: event buffer (200 events × 3 slots each)
//   Each event: [timestamp, value, delta]

CC_BLOCK_SIZE = 600;
CHANNELS_PER_CC = 16;
CC_METRICS_BLOCKS = 128 * CHANNELS_PER_CC;  // 2048 total blocks

/**
 * Gets the memory address for a specific (CC#, Channel) pair's metrics block
 * @param cc_num CC number (0-127)
 * @param channel MIDI channel (0-15)
 * @return Memory address of (CC#, Channel) metrics block
 */
function get_cc_channel_metrics_base(cc_num, channel) (
  metrics_base + (cc_num * CHANNELS_PER_CC + channel) * CC_BLOCK_SIZE
);

/**
 * Initializes the metrics system
 * Clears all buffers and resets counters for all (CC#, Channel) pairs
 */
function init_metrics() local(cc, channel, block_idx) (
  block_idx = 0;
  cc = 0;
  loop(128,
    channel = 0;
    loop(16,
      mem[metrics_base + block_idx * CC_BLOCK_SIZE] = 0;      // Clear event count
      mem[metrics_base + block_idx * CC_BLOCK_SIZE + 1] = -1; // Mark as uninitialized
      block_idx += 1;
      channel += 1;
    );
    cc += 1;
  );
);

/**
 * Adds a new event to the metrics buffer for a (CC#, Channel) pair
 * @param cc_num CC number (0-127)
 * @param channel MIDI channel (0-15)
 * @param value CC value (0-127)
 * @param time_sec Timestamp in seconds
 */
function update_metrics_for_cc_channel(cc_num, channel, value, time_sec) 
  local(base, count, last_val, delta, event_idx, event_ptr) (
  
  base = get_cc_channel_metrics_base(cc_num, channel);
  count = mem[base];
  last_val = mem[base + 1];
  
  // Calculate value delta (for rate calculation)
  delta = last_val >= 0 ? abs(value - last_val) : 0;
  
  // Store this value as last_value for next time
  mem[base + 1] = value;
  
  // Add event to buffer (if space available)
  count < MAX_EVENTS_PER_CC ? (
    event_idx = count;
    event_ptr = base + 2 + (event_idx * 3);
    
    mem[event_ptr] = time_sec;      // Timestamp
    mem[event_ptr + 1] = value;     // CC value
    mem[event_ptr + 2] = delta;     // Value change delta
    
    mem[base] = count + 1;          // Increment count
  );
);

/**
 * Legacy function for backward compatibility (uses channel 0)
 * @deprecated Use update_metrics_for_cc_channel() instead
 */
function update_metrics_for_cc(cc_num, value, time_sec) (
  update_metrics_for_cc_channel(cc_num, 0, value, time_sec);
);

/**
 * Removes events older than METRICS_WINDOW_SEC from all (CC#, Channel) buffers
 * @param current_time_sec Current time in seconds
 */
function prune_old_metrics(current_time_sec) 
  local(cc, channel, base, count, cutoff_time, src_idx, dst_idx, event_ptr, event_time, block_idx) (
  
  cutoff_time = current_time_sec - METRICS_WINDOW_SEC;
  block_idx = 0;
  
  cc = 0;
  loop(128,
    channel = 0;
    loop(16,
      base = metrics_base + block_idx * CC_BLOCK_SIZE;
      count = mem[base];
      
      count > 0 ? (
        dst_idx = 0;
        src_idx = 0;
        
        // Compact buffer: keep only recent events
        loop(count,
          event_ptr = base + 2 + (src_idx * 3);
          event_time = mem[event_ptr];
          
          // Keep this event if it's recent enough
          event_time >= cutoff_time ? (
            src_idx != dst_idx ? (
              // Copy event to new position
              mem[base + 2 + (dst_idx * 3)] = mem[event_ptr];
              mem[base + 2 + (dst_idx * 3) + 1] = mem[event_ptr + 1];
              mem[base + 2 + (dst_idx * 3) + 2] = mem[event_ptr + 2];
            );
            dst_idx += 1;
          );
          
          src_idx += 1;
        );
        
        // Update count
        mem[base] = dst_idx;
      );
      
      block_idx += 1;
      channel += 1;
    );
    cc += 1;
  );
);

/**
 * Calculates events per second for a (CC#, Channel) pair
 * @param cc_num CC number (0-127)
 * @param channel MIDI channel (0-15)
 * @return Number of events in the last second
 */
function get_events_per_second_cc_channel(cc_num, channel) local(base) (
  base = get_cc_channel_metrics_base(cc_num, channel);
  mem[base]  // Event count IS the events per second (in 1-second window)
);

/**
 * Legacy function for backward compatibility (uses channel 0)
 * @deprecated Use get_events_per_second_cc_channel() instead
 */
function get_events_per_second(cc_num) (
  get_events_per_second_cc_channel(cc_num, 0)
);

/**
 * Calculates rate (value change per second) for a (CC#, Channel) pair
 * @param cc_num CC number (0-127)
 * @param channel MIDI channel (0-15)
 * @return Sum of absolute value changes per second
 */
function get_rate_per_second_cc_channel(cc_num, channel) 
  local(base, count, total_delta, i, event_ptr) (
  
  base = get_cc_channel_metrics_base(cc_num, channel);
  count = mem[base];
  
  total_delta = 0;
  i = 0;
  
  loop(count,
    event_ptr = base + 2 + (i * 3);
    total_delta += mem[event_ptr + 2];  // Sum deltas
    i += 1;
  );
  
  total_delta
);

/**
 * Legacy function for backward compatibility (uses channel 0)
 * @deprecated Use get_rate_per_second_cc_channel() instead
 */
function get_rate_per_second(cc_num) (
  get_rate_per_second_cc_channel(cc_num, 0)
);

/**
 * Returns quality rating text for rate value
 * @param rate_value Rate in units per second
 * @return Quality string: "Gentle", "Moderate", "Active", or "Aggressive"
 */
function get_rate_quality(rate_value) (
  rate_value <= 15 ? "Gentle" :
  rate_value <= 40 ? "Moderate" :
  rate_value <= 70 ? "Active" :
  "Aggressive"
);

/**
 * Calculates jitter (timing consistency) for a (CC#, Channel) pair
 * Returns standard deviation of time intervals between events
 * @param cc_num CC number (0-127)
 * @param channel MIDI channel (0-15)
 * @return Jitter in milliseconds (±)
 */
function get_jitter_ms_cc_channel(cc_num, channel) 
  local(base, count, i, event_ptr, prev_time, curr_time, interval,
        sum_intervals, mean_interval, sum_squared_diff, variance, stddev) (
  
  base = get_cc_channel_metrics_base(cc_num, channel);
  count = mem[base];
  
  // Need at least 2 events to calculate jitter
  count < 2 ? (
    0
  ) : (
    // Calculate mean interval
    sum_intervals = 0;
    i = 1;
    loop(count - 1,
      prev_time = mem[base + 2 + ((i - 1) * 3)];
      curr_time = mem[base + 2 + (i * 3)];
      sum_intervals += (curr_time - prev_time);
      i += 1;
    );
    mean_interval = sum_intervals / (count - 1);
    
    // Calculate variance
    sum_squared_diff = 0;
    i = 1;
    loop(count - 1,
      prev_time = mem[base + 2 + ((i - 1) * 3)];
      curr_time = mem[base + 2 + (i * 3)];
      interval = curr_time - prev_time;
      sum_squared_diff += (interval - mean_interval) * (interval - mean_interval);
      i += 1;
    );
    variance = sum_squared_diff / (count - 1);
    
    // Standard deviation in milliseconds
    stddev = sqrt(variance) * 1000;
    stddev
  );
);

/**
 * Legacy function for backward compatibility (uses channel 0)
 * @deprecated Use get_jitter_ms_cc_channel() instead
 */
function get_jitter_ms(cc_num) (
  get_jitter_ms_cc_channel(cc_num, 0)
);

/**
 * Returns quality rating text for jitter value
 * @param jitter_ms Jitter in milliseconds
 * @return Quality string: "Excellent", "Very Good", "Good", "Fair", or "Poor"
 */
function get_jitter_quality(jitter_ms) (
  jitter_ms <= 5 ? "Excellent" :
  jitter_ms <= 15 ? "Very Good" :
  jitter_ms <= 30 ? "Good" :
  jitter_ms <= 50 ? "Fair" :
  "Poor"
);

// Initialize metrics system
init_metrics();
